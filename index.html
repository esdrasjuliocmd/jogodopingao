export class RoomDO {
  constructor(state, env) {
    this.state = state;
    this.jogadores = []; 
    this.jogoAndamento = false;
    this.rodadaAtiva = false;
    this.faseNegociacao = false;
    this.timer = null;
    this.numeroRodada = 0;
    this.poteAcumulado = 0;
    this.chatLog = []; 
  }

  async fetch(request) {
    const [client, server] = new WebSocketPair();
    server.accept();

    server.onmessage = (msg) => {
      const data = JSON.parse(msg.data);
      const sender = this.jogadores.find(j => j.socket === server);

      if (data.type === 'JOIN') {
        const isPrimeiro = this.jogadores.length === 0;
        
        // AJUSTE CIR√öRGICO: Recupera estado se o jogador j√° existia (reconex√£o)
        const jogadorExistente = this.jogadores.find(j => j.nome === data.nome);
        
        const novo = { 
            nome: data.nome, 
            pronto: false, 
            socket: server, 
            resultado: null, 
            distancia: 999,
            fichas: jogadorExistente ? jogadorExistente.fichas : 500, 
            eliminado: jogadorExistente ? jogadorExistente.eliminado : false, 
            esperandoProxima: this.jogoAndamento, 
            tempoGasto: 60,
            pulouVez: jogadorExistente ? jogadorExistente.pulouVez : false, 
            isHost: jogadorExistente ? jogadorExistente.isHost : isPrimeiro, 
            desistiu: false 
        };

        // Remove a refer√™ncia antiga e adiciona a nova com o novo Socket
        this.jogadores = this.jogadores.filter(j => j.nome !== data.nome);
        this.jogadores.push(novo);

        server.send(JSON.stringify({ type: 'INFO_PLAYER', isHost: novo.isHost }));
        this.broadcastState();
        if (this.jogoAndamento) server.send(JSON.stringify({ type: 'ESPERANDO_RODADA', rodada: this.numeroRodada }));
      }

      if (data.type === 'START') {
        if (!sender || !sender.isHost) return; 
        if (!this.jogoAndamento) {
            this.jogoAndamento = true; this.numeroRodada = 0; this.poteAcumulado = 0; this.chatLog = [];
            this.jogadores.forEach(j => { j.fichas = 500; j.eliminado = false; j.esperandoProxima = false; j.pulouVez = false; j.desistiu = false; });
            this.iniciarNovaRodada();
        }
      }

      if (data.type === 'ENCERRAR_DISCORDIA') {
        if (!sender || !sender.isHost) return;
        if (this.faseNegociacao) this.iniciarNovaRodada();
      }

      if (data.type === 'CHAT_MSG') {
        this.chatLog.push({ nome: data.nome, msg: data.msg });
        if(this.chatLog.length > 30) this.chatLog.shift();
        this.broadcast({ type: 'CHAT_UPDATE', log: this.chatLog });
      }

      if (data.type === 'DOAR_FICHAS') {
        if (!this.faseNegociacao) return;
        const doador = this.jogadores.find(j => j.nome === data.de);
        const recebedor = this.jogadores.find(j => j.nome === data.para);
        const valor = parseInt(data.valor);
        if (doador && recebedor && doador.fichas >= valor && !doador.eliminado && !recebedor.eliminado) {
            doador.fichas -= valor; recebedor.fichas += valor; doador.pulouVez = true;
            this.chatLog.push({ sistema: true, msg: `üí∏ ${doador.nome} enviou ${valor} para ${recebedor.nome} e pulou a vez!` });
            this.broadcast({ type: 'CHAT_UPDATE', log: this.chatLog });
            this.broadcastState();
        }
      }

      if (data.type === 'DESISTIR') {
        const jogador = this.jogadores.find(j => j.nome === data.nome);
        if (jogador && this.rodadaAtiva && !jogador.eliminado && !jogador.esperandoProxima && !jogador.pulouVez && !jogador.pronto) {
            jogador.pronto = true;
            jogador.desistiu = true;
            jogador.resultado = "DESISTIU";
            jogador.distancia = 9999; 
            jogador.tempoGasto = 999; 
            this.broadcastState();
            this.verificarFimDeRodada();
        }
      }

      if (data.type === 'JOGADA') {
        const jogador = this.jogadores.find(j => j.nome === data.nome);
        if (jogador && this.rodadaAtiva && !jogador.eliminado && !jogador.esperandoProxima && !jogador.pulouVez) {
          jogador.pronto = true; jogador.resultado = data.valor; jogador.distancia = data.distancia;
          jogador.tempoGasto = data.tempo || 60; 
          this.broadcastState();
          this.verificarFimDeRodada();
        }
      }
    };

    server.onclose = () => {
      const saindo = this.jogadores.find(j => j.socket === server);
      if(saindo) {
          // N√£o eliminamos imediatamente para permitir reconex√£o r√°pida, 
          // apenas marcamos o socket como nulo ou deixamos como est√°.
          if (saindo.isHost) {
              const novoHost = this.jogadores.find(j => !j.eliminado && j !== saindo && j.socket);
              if (novoHost) {
                  saindo.isHost = false;
                  novoHost.isHost = true;
                  try { novoHost.socket.send(JSON.stringify({ type: 'INFO_PLAYER', isHost: true })); } catch(e){}
              }
          }
      }
      this.broadcastState();
    };
    return new Response(null, { status: 101, webSocket: client });
  }

  iniciarNovaRodada() {
    if (!this.faseNegociacao && (this.numeroRodada + 1) % 5 === 0 && this.numeroRodada > 0) {
        this.iniciarNegociacao(); return;
    }
    this.faseNegociacao = false; this.rodadaAtiva = true; this.numeroRodada++;

    const vivos = this.jogadores.filter(j => !j.eliminado);
    if (vivos.length <= 1 && this.numeroRodada > 1) {
        this.jogoAndamento = false;
        const campeao = vivos[0] || {nome: "Ningu√©m", fichas: 0};
        campeao.fichas += this.poteAcumulado;
        const placarFinal = this.jogadores.map(j => ({ nome: j.nome, fichas: j.fichas, eliminado: j.eliminado })).sort((a,b) => b.fichas - a.fichas);
        this.broadcast({ type: 'GAME_OVER', vencedor: campeao.nome, totalFichas: campeao.fichas, placar: placarFinal });
        return;
    }

    const base = Math.random() < 0.5 ? 1 : 11;
    const variacao = Math.floor(Math.random() * 7) - 3;
    const alvo = base + variacao;

    let baralho = [];
    for(let i=0; i<4; i++) for(let n=1; n<=13; n++) baralho.push(n);
    for (let i = baralho.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [baralho[i], baralho[j]] = [baralho[j], baralho[i]]; }

    this.jogadores.forEach(j => {
        if(!j.eliminado) j.esperandoProxima = false;
        j.pronto = false; j.resultado = null; j.distancia = 999; j.tempoGasto = 0; j.desistiu = false;
        if (j.pulouVez) { try { j.socket.send(JSON.stringify({ type: 'PULOU_VEZ', rodada: this.numeroRodada })); } catch(e) {} } 
        else if (!j.eliminado && !j.esperandoProxima) {
            const mao = [baralho.pop(), baralho.pop(), baralho.pop(), baralho.pop()];
            try { j.socket.send(JSON.stringify({ type: 'SUA_MAO', cartas: mao, alvo: alvo, tempo: 60, rodada: this.numeroRodada, fichas: j.fichas })); } catch(e) {}
        }
    });
    this.broadcastState();
    if(this.timer) clearTimeout(this.timer);
    this.timer = setTimeout(() => { this.finalizarRodada(); }, 60000);
  }

  iniciarNegociacao() {
    this.faseNegociacao = true; this.chatLog = []; 
    this.broadcast({ type: 'INICIO_NEGOCIACAO' }); 
    if(this.timer) clearTimeout(this.timer);
  }

  verificarFimDeRodada() {
    const jogando = this.jogadores.filter(j => !j.eliminado && !j.esperandoProxima && !j.pulouVez);
    if (jogando.length > 0 && jogando.every(j => j.pronto)) {
        if(this.timer) clearTimeout(this.timer);
        this.finalizarRodada();
    }
  }

  finalizarRodada() {
    if(!this.rodadaAtiva) return;
    this.rodadaAtiva = false;
    this.jogadores.forEach(j => j.pulouVez = false);

    const jogando = this.jogadores.filter(j => !j.eliminado && !j.esperandoProxima && j.resultado !== null && !j.desistiu);
    
    let vencedorNome = "Ningu√©m";
    let vencedorValor = "-";
    let vencedorDist = "-";
    let premio = 0;
    let tempoVencedor = 0;

    if(jogando.length > 0) {
        const vencedor = jogando.reduce((prev, curr) => {
            if (prev.distancia < curr.distancia) return prev;
            if (curr.distancia < prev.distancia) return curr;
            return (prev.tempoGasto < curr.tempoGasto) ? prev : curr;
        });

        if (vencedor.tempoGasto <= 20) premio = 100;
        else if (vencedor.tempoGasto <= 30) premio = 80;
        else if (vencedor.tempoGasto <= 40) premio = 30; 
        else if (vencedor.tempoGasto <= 50) premio = -15; 
        else premio = -30;

        vencedor.fichas += premio;
        vencedorNome = vencedor.nome;
        vencedorValor = vencedor.resultado;
        vencedorDist = vencedor.distancia;
        tempoVencedor = vencedor.tempoGasto;
    }

    let msgEliminacao = "";
    if (this.numeroRodada % 5 === 0) {
        const vivos = this.jogadores.filter(j => !j.eliminado);
        if (vivos.length > 1) {
            // AJUSTE CIR√öRGICO: Crit√©rio de desempate por tempo gasto total se fichas forem iguais
            vivos.sort((a, b) => {
                if(a.fichas !== b.fichas) return a.fichas - b.fichas;
                return b.tempoGasto - a.tempoGasto; // Quem demorou mais morre no empate
            });
            const eliminado = vivos[0];
            eliminado.eliminado = true;
            this.poteAcumulado += eliminado.fichas;
            eliminado.fichas = 0;
            msgEliminacao = `üíÄ ${eliminado.nome} FOI ELIMINADO!`;
        }
    }
    this.broadcast({ type: 'FIM_RODADA', vencedor: vencedorNome, valor: vencedorValor, dist: vencedorDist, premio: premio, tempo: tempoVencedor, msgExtra: msgEliminacao });

    let segundos = 8;
    const timerContagem = setInterval(() => {
        segundos--;
        this.broadcast({ type: 'CONTAGEM', tempo: segundos });
        if (segundos <= 0) { clearInterval(timerContagem); this.iniciarNovaRodada(); }
    }, 1000);
  }

  broadcastState() {
    const lista = this.jogadores.map(j => ({ nome: j.nome, pronto: j.pronto, fichas: j.fichas, eliminado: j.eliminado, esperando: j.esperandoProxima, pulou: j.pulouVez, isHost: j.isHost, desistiu: j.desistiu }));
    this.broadcast({ type: 'LISTA', lista: lista, rodada: this.numeroRodada });
  }
  broadcast(msg) { this.jogadores.forEach(j => { try { if(j.socket) j.socket.send(JSON.stringify(msg)); } catch(e) {} }); }
}

export default {
  async fetch(request, env) {
    if (request.headers.get("Upgrade") === "websocket") {
      const url = new URL(request.url);
      const salaNome = url.searchParams.get("sala") || "sala-padrao";
      const id = env.RoomDO.idFromName(salaNome);
      return env.RoomDO.get(id).fetch(request);
    }
    return new Response("Ping√£o Estrategia V11");
  }
};
